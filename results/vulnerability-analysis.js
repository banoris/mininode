const fs = require('fs');
const readline = require('readline');
const jfs = require('jsonfile');
const semver = require('semver');
const argv = require('yargs').argv;

if (!argv.file) {
    console.error('--file is required');
    process.exit(1);
} else if (!argv.field) {
    console.error('--field is required');
    process.exit(2);
}

let advisories = jfs.readFileSync('./data/advisories.json');

let allVulns = new Set();

for (let adv of advisories.advisories) {
    adv.count = 0;
    if (!advisories.categories.find((item) => { return item.name === adv.category.toLowerCase().trim()})) {
        advisories.categories.push({
            name: adv.category.toLowerCase().trim(),
            high: new Set(),
            medium: new Set(),
            low: new Set(),
            total: new Set()
        })
    }
}

let liner = readline.createInterface({
    input: fs.createReadStream(argv.file, {encoding: 'utf8'})
});

let count = 0;
liner.on('line', function(line) {
    let doc = JSON.parse(line);
    console.log(count++, doc.path);
    let dependencies = doc.dependencies;
    // 1. replace all (dot) with .
    for (let key of Object.keys(dependencies)) {
        let nkey = key.replace(/\(dot\)/g, '.');
        if (nkey !== key) {
            dependencies[nkey] = dependencies[key];
            delete dependencies[key];
        }
    }
    for (let adv of advisories.advisories) {
        if (Object.prototype.hasOwnProperty.call(dependencies, adv.name)) {
            for (const version of dependencies[adv.name]) {
                if (semver.satisfies(version, adv.semver)) {
                    adv.count++;
                    let category = advisories.categories.find((item) => {return item.name === adv.category.toLowerCase().trim()});
                    if (adv.severity === 'H') category.high.add(doc.path);
                    else if(adv.severity === 'M') category.medium.add(doc.path);
                    else category.low.add(doc.path);
                    category.total.add(doc.path);
                    allVulns.add(doc.path);
                    break;
                }
            }
        }
    }
});
liner.on('close', ()=>{
    for (let adv of advisories.advisories) {
        adv[argv.field] = adv.count;
        delete adv.count;
    }
    for (let category of advisories.categories) {
        category.low = category.low.size;
        category.medium = category.medium.size;
        category.high = category.high.size;
        category.total = category.total.size;
    }
    jfs.writeFileSync('./data/advisories.json', advisories, {spaces: 2});
    jfs.writeFileSync('./data/vulnerables.json', [...allVulns], {spaces: 2});
})